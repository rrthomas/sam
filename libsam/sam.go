// Bind libsam into Go.
package libsam

//#cgo LDFLAGS: -lm
//#cgo CFLAGS: -DSAM_DEBUG
//#cgo pkg-config: sdl2 SDL2_gfx
//#include "sam.h"
//#include "sam_opcodes.h"
import "C"
import "fmt"

type Word = C.sam_word_t
type Uword = C.sam_uword_t

var TAG_SHIFT = C.SAM_TAG_SHIFT
var TAG_MASK = C.SAM_TAG_MASK
var ATOM_TYPE_SHIFT = C.SAM_ATOM_TYPE_SHIFT
var ATOM_TYPE_MASK = C.SAM_ATOM_TYPE_MASK
var BIATOM_TAG_SHIFT = C.SAM_BIATOM_TAG_SHIFT
var BIATOM_TAG_MASK = C.SAM_BIATOM_TAG_MASK
var BIATOM_TYPE_SHIFT = C.SAM_BIATOM_TYPE_SHIFT
var BIATOM_TYPE_MASK = C.SAM_BIATOM_TYPE_MASK
var ARRAY_TYPE_SHIFT = C.SAM_ARRAY_TYPE_SHIFT
var ARRAY_TYPE_MASK = C.SAM_ARRAY_TYPE_MASK
var OPERAND_SHIFT = C.SAM_OPERAND_SHIFT
var OPERAND_MASK = C.SAM_OPERAND_MASK
var LINK_SHIFT = C.SAM_LINK_SHIFT
var LINK_MASK = C.SAM_LINK_MASK
var WORD_MASK = Uword(((1 << C.SAM_WORD_BIT) - 1))

func Run(pc0 Uword, pc Uword) Word {
	C.sam_pc0 = pc0
	C.sam_pc = pc
	return C.sam_run()
}

func Init(m0 []Word, msize Uword, sp Uword) int {
	return int(C.sam_init(&m0[0], msize, sp))
}

func TrapsInit() Word {
	return C.sam_traps_init()
}

func TrapsFinish() {
	C.sam_traps_finish()
}

func TrapsWindowUsed() bool {
	return C.sam_traps_window_used() != 0
}

func TrapsWait() {
	C.sam_traps_wait()
}

func SetDebug(flag bool) {
	if flag {
		C.do_debug = true
	} else {
		C.do_debug = false
	}
}

func StackPeek(addr Uword) (int, Uword) {
	var val Uword
	res := C.sam_stack_peek(addr, &val)
	return int(res), val
}

func PrintStack() {
	C.sam_print_stack()
}

func DumpScreen(file string) {
	C.sam_dump_screen(C.CString(file))
}

const (
	ERROR_OK               = C.SAM_ERROR_OK
	ERROR_HALT             = C.SAM_ERROR_HALT
	ERROR_INVALID_OPCODE   = C.SAM_ERROR_INVALID_OPCODE
	ERROR_INVALID_ADDRESS  = C.SAM_ERROR_INVALID_ADDRESS
	ERROR_STACK_UNDERFLOW  = C.SAM_ERROR_STACK_UNDERFLOW
	ERROR_STACK_OVERFLOW   = C.SAM_ERROR_STACK_OVERFLOW
	ERROR_WRONG_TYPE       = C.SAM_ERROR_WRONG_TYPE
	ERROR_BAD_BRACKET      = C.SAM_ERROR_BAD_BRACKET
	ERROR_UNPAIRED_BIATOM  = C.SAM_ERROR_UNPAIRED_BIATOM
	ERROR_INVALID_FUNCTION = C.SAM_ERROR_INVALID_FUNCTION
	ERROR_TRAP_INIT        = C.SAM_ERROR_TRAP_INIT
)

const (
	TAG_LINK   = C.SAM_TAG_LINK
	TAG_ATOM   = C.SAM_TAG_ATOM
	TAG_BIATOM = C.SAM_TAG_BIATOM
	TAG_ARRAY  = C.SAM_TAG_ARRAY
)

const (
	ATOM_INST = C.SAM_ATOM_INST
	ATOM_INT  = C.SAM_ATOM_INT
	ATOM_CHAR = C.SAM_ATOM_CHAR
)

const (
	BIATOM_FIRST  = C.SAM_BIATOM_FIRST
	BIATOM_SECOND = C.SAM_BIATOM_SECOND
)

const (
	BIATOM_WORD  = C.SAM_BIATOM_WORD
	BIATOM_FLOAT = C.SAM_BIATOM_FLOAT
)

const (
	ARRAY_STACK = C.SAM_ARRAY_STACK
	ARRAY_RAW   = C.SAM_ARRAY_RAW
)

var errors = map[int]string{
	ERROR_OK:               "ERROR_OK",
	ERROR_HALT:             "ERROR_HALT",
	ERROR_INVALID_OPCODE:   "ERROR_INVALID_OPCODE",
	ERROR_INVALID_ADDRESS:  "ERROR_INVALID_ADDRESS",
	ERROR_STACK_UNDERFLOW:  "ERROR_STACK_UNDERFLOW",
	ERROR_STACK_OVERFLOW:   "ERROR_STACK_OVERFLOW",
	ERROR_WRONG_TYPE:       "ERROR_WRONG_TYPE",
	ERROR_BAD_BRACKET:      "ERROR_BAD_BRACKET",
	ERROR_UNPAIRED_BIATOM:  "ERROR_UNPAIRED_BIATOM",
	ERROR_INVALID_FUNCTION: "ERROR_INVALID_FUNCTION",
	ERROR_TRAP_INIT:        "ERROR_TRAP_INIT",
}

func ErrorMessage(code Word) string {
	baseCode := code & ^OPERAND_MASK
	if baseCode >= ERROR_OK && baseCode <= ERROR_TRAP_INIT {
		reasonCode := code >> OPERAND_SHIFT
		if baseCode == ERROR_HALT {
			return fmt.Sprintf("halt with reason %d (0x%x)", reasonCode, uint(reasonCode))
		}
		return fmt.Sprintf(errors[int(baseCode)])
	}
	return fmt.Sprintf("unknown code %d (0x%x)", code, uint(Uword(code)&WORD_MASK))
}

var Instructions = map[string]int{
	// Tag instructions
	"link": C.SAM_TAG_LINK,

	// Atom instructions
	"int":  C.SAM_TAG_ATOM | (C.SAM_ATOM_INT << C.SAM_ATOM_TYPE_SHIFT),
	"char": C.SAM_TAG_ATOM | (C.SAM_ATOM_CHAR << C.SAM_ATOM_TYPE_SHIFT),

	// Biatom instructions
	"word":  C.SAM_TAG_BIATOM | (C.SAM_BIATOM_WORD << C.SAM_BIATOM_TYPE_SHIFT),
	"float": C.SAM_TAG_BIATOM | (C.SAM_BIATOM_FLOAT << C.SAM_BIATOM_TYPE_SHIFT),

	// Niladic instructions
	"nop":   C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_NOP << C.SAM_OPERAND_SHIFT),
	"i2f":   C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_I2F << C.SAM_OPERAND_SHIFT),
	"f2i":   C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_F2I << C.SAM_OPERAND_SHIFT),
	"pop":   C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_POP << C.SAM_OPERAND_SHIFT),
	"get":   C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_GET << C.SAM_OPERAND_SHIFT),
	"set":   C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_SET << C.SAM_OPERAND_SHIFT),
	"iget":  C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_IGET << C.SAM_OPERAND_SHIFT),
	"iset":  C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_ISET << C.SAM_OPERAND_SHIFT),
	"do":    C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_DO << C.SAM_OPERAND_SHIFT),
	"if":    C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_IF << C.SAM_OPERAND_SHIFT),
	"while": C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_WHILE << C.SAM_OPERAND_SHIFT),
	"loop":  C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_LOOP << C.SAM_OPERAND_SHIFT),
	"not":   C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_NOT << C.SAM_OPERAND_SHIFT),
	"and":   C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_AND << C.SAM_OPERAND_SHIFT),
	"or":    C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_OR << C.SAM_OPERAND_SHIFT),
	"xor":   C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_XOR << C.SAM_OPERAND_SHIFT),
	"lsh":   C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_LSH << C.SAM_OPERAND_SHIFT),
	"rsh":   C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_RSH << C.SAM_OPERAND_SHIFT),
	"arsh":  C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_ARSH << C.SAM_OPERAND_SHIFT),
	"eq":    C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_EQ << C.SAM_OPERAND_SHIFT),
	"lt":    C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_LT << C.SAM_OPERAND_SHIFT),
	"neg":   C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_NEG << C.SAM_OPERAND_SHIFT),
	"add":   C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_ADD << C.SAM_OPERAND_SHIFT),
	"mul":   C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_MUL << C.SAM_OPERAND_SHIFT),
	"div":   C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_DIV << C.SAM_OPERAND_SHIFT),
	"rem":   C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_REM << C.SAM_OPERAND_SHIFT),
	"pow":   C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_POW << C.SAM_OPERAND_SHIFT),
	"sin":   C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_SIN << C.SAM_OPERAND_SHIFT),
	"cos":   C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_COS << C.SAM_OPERAND_SHIFT),
	"deg":   C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_DEG << C.SAM_OPERAND_SHIFT),
	"rad":   C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_RAD << C.SAM_OPERAND_SHIFT),
	"halt":  C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_HALT << C.SAM_OPERAND_SHIFT),

	// Trap
	"trap": C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT),
}

var Traps = map[string]int{
	"BLACK":          C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_BLACK << C.SAM_OPERAND_SHIFT),
	"WHITE":          C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_WHITE << C.SAM_OPERAND_SHIFT),
	"DISPLAY_WIDTH":  C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_DISPLAY_WIDTH << C.SAM_OPERAND_SHIFT),
	"DISPLAY_HEIGHT": C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_DISPLAY_HEIGHT << C.SAM_OPERAND_SHIFT),
	"CLEARSCREEN":    C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_CLEARSCREEN << C.SAM_OPERAND_SHIFT),
	"SETDOT":         C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_SETDOT << C.SAM_OPERAND_SHIFT),
	"DRAWLINE":       C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_DRAWLINE << C.SAM_OPERAND_SHIFT),
	"DRAWRECT":       C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_DRAWRECT << C.SAM_OPERAND_SHIFT),
	"DRAWROUNDRECT":  C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_DRAWROUNDRECT << C.SAM_OPERAND_SHIFT),
	"FILLRECT":       C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_FILLRECT << C.SAM_OPERAND_SHIFT),
	"DRAWCIRCLE":     C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_DRAWCIRCLE << C.SAM_OPERAND_SHIFT),
	"FILLCIRCLE":     C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_FILLCIRCLE << C.SAM_OPERAND_SHIFT),
	"DRAWBITMAP":     C.SAM_TAG_ATOM | (C.SAM_ATOM_INST << C.SAM_ATOM_TYPE_SHIFT) | (C.INST_DRAWBITMAP << C.SAM_OPERAND_SHIFT),
}
